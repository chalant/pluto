syntax = "proto3";

import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "protos/metrics.proto";

import "protos/clock.proto";

import "protos/data.proto";

service Controller {
    //This method is a callback for controllables: each controllable sends back a performance
    //packet to the controller by specifying the session_id in the metadata
    rpc PerformancePacketUpdate (stream Data) returns (google.protobuf.Empty);
    rpc Stop (StopParams) returns (StopStatus);
    //orders liquidation of all assets in all the controllables
    rpc Liquidate(google.protobuf.Empty) returns (google.protobuf.Empty);
    //we can watch the performance of the strategy in real-time...
    /*rpc Watch (StrategyID) returns (stream Data);*/
    //dynamically updates capital and/or leverage of a running strategy
    //NOTE: this information can be obtained from the broker. ex: interactive brokers...
    //The controller holds the master account which contains the initial capital of the account...
    rpc UpdateLevCap (stream LevCap) returns (CapitalAssignmentStatus);
    rpc ClockUpdate (ClockEvent) returns (google.protobuf.Empty);
    //TODO: should be able to check for available domains.
    rpc Deploy(stream Data) returns (google.protobuf.Empty);
    rpc UpdateGraph(stream Data) returns (google.protobuf.Empty);
}

enum SessionStatus {
    COMPLETED = 0;
    INTERRUPTED = 1;
}

message Status {
    SessionStatus session_status = 1;
}

message CapitalUpdate {
    float capital_ratio = 1;
    string session_id = 2;
}

message MaxLeverageUpdate{
    float max_leverage = 1;
    string session_id = 2;
}

message LevCap {
    float capital_ratio = 1;
    float max_leverage = 2;
    string session_id = 3; //strategy id
}

message CapitalAssignmentStatus {

}

message DelimitedRunParams {
    repeated RunParams run_params = 1;
    google.protobuf.Timestamp start_date = 2;
    google.protobuf.Timestamp end_date = 3;
}

message RunParams {
    string session_id = 1;
    float capital_ratio = 2;
    float max_leverage = 3;
    //TODO: the benchmark asset should be set depending on the domain (not manually)
    // the emission_rate and the data frequency should be inferred from the domain
    //start date and end date should be inferred from the environment
    Frequency emission_rate = 4;
    string benchmark_asset = 5;
    Frequency data_frequency = 6;
}

message StopParams {
    bool liquidate = 1;
}


message StopStatus {

}

message Performance {
    repeated PerformancePacket packets = 1;
}

message PerformancePacket {
    CumulativeMetrics cumulative_perf = 1;
    PeriodPerformance daily_perf = 2;
    PeriodPerformance minutely_perf = 3;
    CumulativeRiskMetrics cumulative_risk_metrics = 4;
    string id = 5;
}

message PeriodPerformance {
    CumulativeMetrics cumulative_metrics = 1;
    PeriodCommonMetrics period_common_metrics = 2;
}

enum ControllerEvent {
    CAPITAL_CHANGE = 0;
    LEVERAGE_CHANGE = 1;
    BROKER_UPDATE = 2;
}

message ParametersUpdateRequest {
    ControllerEvent controller_event = 1;
    float capital = 2;
    float maximum_leverage = 3;
}