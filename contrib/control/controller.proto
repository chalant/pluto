syntax = "proto3";

import "google/protobuf/empty.proto";
import "contrib/coms/protos/metrics.proto";
import "contrib/coms/protos/data_bundle.proto";

import "contrib/control/clock.proto";

service Controller {
    //deploys a strategy
    rpc Deploy(stream Strategy) returns (stream DeploymentStatus);
    //This method is a callback for controllables: each controllable sends back a performance
    //packet to the controller
    rpc PerformancePacketUpdate(PerformancePacket) returns (google.protobuf.Empty);
    rpc Stop(StopParams) returns (StopStatus);
    //runs a strategy with initial parameters
    rpc Run(RunParams) returns (Status);
    //we can watch the performance of the strategy in real-time...
    rpc Watch(ID) returns (stream PerformancePacket);
    rpc GetStrategy(ID) returns (stream Strategy);
    //retrieve the environment on which the strategy will be developed
    rpc GetEnvironment(Domain) returns (stream Environment);
    //returns a list of deployed strategies
    rpc GetStrategyList(Filter) returns (stream Strategy);
    //dynamically updates capital and/or leverage of a running strategy
    rpc UpdateLevCap(LevCap) returns (CapitalAssignmentStatus);
    //TODO: should be able to check for available domains.
}

message InitializationParameters{
    bytes strategy = 1;
    bytes state = 2;
}

message SessionState{
    bytes state = 1;
}

message DeploymentStatus {
    //TODO: should return the deployment status : (rejected if is a duplicate etc.) and
    // the reason of the rejection (maybe give a vi)
    bytes strategy = 1;
}

message Status {
    StatusEnum status = 1;
    string id = 2;
}

message LevCap {
    float capital = 1;
    float max_leverage = 2;
}

message CapitalAssignmentStatus {

}

message Environment {
    bytes environment = 1;
}

message Strategy {
    bytes script = 1;
}

message Filter {
    StatusEnum status = 1;
}

enum StatusEnum {
    Running = 0;
    Pending = 1;
}

message RunParams {
    string id = 1;
    int64 capital = 2;
    float max_leverage = 3;

    //TODO: the benchmark asset should be set depending on the domain (not manually)
    // the emission_rate and the data frequency should be inferred from the domain
    //start date and end date should be inferred from the environment
    Frequency emission_rate = 4;
    string benchmark_asset = 5;
    Frequency data_frequency = 6;
}

message StopParams {
    string id = 1;
    bool liquidate = 2;
}


message StopStatus {

}


message ID {
}

message PerformancePacket {
    CumulativeMetrics cumulative_perf = 1;
    PeriodPerformance daily_perf = 2;
    PeriodPerformance minutely_perf = 3;
    CumulativeRiskMetrics cumulative_risk_metrics = 4;
}

message PeriodPerformance {
    CumulativeMetrics cumulative_metrics = 1;
    PeriodCommonMetrics period_common_metrics = 2;
}

enum ControllerEvent {
    CAPITAL_CHANGE = 0;
    LEVERAGE_CHANGE = 1;
    BROKER_UPDATE = 2;
}

message ParametersUpdateMessage {
    ControllerEvent controller_event = 1;
    float capital = 2;
    float maximum_leverage = 3;
}
